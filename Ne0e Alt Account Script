-- Ne0e Alt Account Control (mirror, spinorbit, bodyguard, gelişmiş dans paneli, animasyon scroll up/down)

local config = {
    mainAccount = "Xper1tiz",
    altAccount = "semih53sn2",
    commands = {
        ".goto <kullanıcı>",
        ".follow <kullanıcı>",
        ".stop",
        ".spin",
        ".unspin",
        ".orbit <kullanıcı>",
        ".unorbit",
        ".spinorbit <kullanıcı>",
        ".fling <kullanıcı>",
        ".lag",
        ".unlag",
        ".re",
        ".chat <mesaj>",
        ".bang <kullanıcı>",
        ".unbang",
        ".headsit <kullanıcı>",
        ".unheadsit",
        ".mirror <kullanıcı>",
        ".bodyguard <kullanıcı>",
        ".joke",
        ".quit"
        -- DANCE KOMUTLARI SADECE PANELDE!
    },
    dancePanelCommands = {
        {name = ".dance1", anim = "emote:dance"},
        {name = ".dance2", anim = "emote:dance2"},
        {name = ".dance3", anim = "emote:dance3"},
        {name = ".headthrow", anim = "rbxassetid://35154961"},
        {name = ".infiniterunnerrun", anim = "rbxassetid://252557606"},
    }
}

local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local isMain = (lp.Name == config.mainAccount)
local isAlt = (lp.Name == config.altAccount)

pcall(function()
    StarterGui:SetCore("SendNotification", {
        Title = "Ne0e Alt Control",
        Text = "Script başarıyla başlatıldı!",
        Duration = 5
    })
end)

local function findPlayerByPartialName(partial)
    partial = partial:lower()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Name:lower():sub(1, #partial) == partial then
            return plr
        end
    end
    return nil
end

if isAlt then
    local gui = Instance.new("ScreenGui")
    gui.Name = "Ne0eAltAccountScreen"
    gui.Parent = lp:WaitForChild("PlayerGui")
    gui.ResetOnSpawn = false

    local bg = Instance.new("Frame", gui)
    bg.Size = UDim2.new(1,0,1,0)
    bg.Position = UDim2.new(0,0,0,0)
    bg.BackgroundColor3 = Color3.new(0,0,0)

    local label = Instance.new("TextLabel", bg)
    label.Size = UDim2.new(1,0,1,0)
    label.Position = UDim2.new(0,0,0,0)
    label.BackgroundTransparency = 1
    label.Text = "Ne0e Alt Account Script Working"
    label.TextColor3 = Color3.fromRGB(80, 255, 180)
    label.Font = Enum.Font.GothamBlack
    label.TextScaled = true
end

if isMain then
    local gui = Instance.new("ScreenGui")
    gui.Name = "Ne0eAltAccountCmdList"
    gui.Parent = lp:WaitForChild("PlayerGui")
    gui.ResetOnSpawn = false

    local main = Instance.new("Frame", gui)
    main.Size = UDim2.new(0, 360, 0, 420)
    main.Position = UDim2.new(0, 40, 0, 120)
    main.BackgroundColor3 = Color3.fromRGB(32, 34, 44)
    main.BorderSizePixel = 0
    main.Active = true
    main.Draggable = true
    local mainCorner = Instance.new("UICorner", main)
    mainCorner.CornerRadius = UDim.new(0, 12)

    local title = Instance.new("TextLabel", main)
    title.Size = UDim2.new(1, 0, 0, 32)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(22, 22, 28)
    title.Text = "Ne0e Alt Account Panel"
    title.TextColor3 = Color3.fromRGB(80, 180, 255)
    title.Font = Enum.Font.GothamBlack
    title.TextScaled = true
    title.BorderSizePixel = 0
    local titleCorner = Instance.new("UICorner", title)
    titleCorner.CornerRadius = UDim.new(0, 12)

    -- TAB BAR (sadece 2 tab)
    local tabBar = Instance.new("Frame", main)
    tabBar.Size = UDim2.new(1, -24, 0, 36)
    tabBar.Position = UDim2.new(0, 12, 0, 40)
    tabBar.BackgroundTransparency = 1

    local tabNames = {"Commands", "Animations"}
    local tabs = {}
    local selectedTab = 1

    for i, tabName in ipairs(tabNames) do
        local tabBtn = Instance.new("TextButton", tabBar)
        tabBtn.Size = UDim2.new(0, 140, 1, 0)
        tabBtn.Position = UDim2.new(0, (i-1)*150, 0, 0)
        tabBtn.BackgroundColor3 = i == selectedTab and Color3.fromRGB(80,180,255) or Color3.fromRGB(44,48,70)
        tabBtn.Text = tabName
        tabBtn.TextColor3 = Color3.fromRGB(30,30,40)
        tabBtn.Font = Enum.Font.GothamBold
        tabBtn.TextScaled = true
        tabBtn.BorderSizePixel = 0
        local tabBtnCorner = Instance.new("UICorner", tabBtn)
        tabBtnCorner.CornerRadius = UDim.new(0, 8)
        tabs[i] = tabBtn
    end

    -- PANELLER
    local panels = {}

    -- Commands Panel
    local cmdPanel = Instance.new("Frame", main)
    cmdPanel.Size = UDim2.new(1, -24, 1, -92)
    cmdPanel.Position = UDim2.new(0, 12, 0, 80)
    cmdPanel.BackgroundColor3 = Color3.fromRGB(44, 48, 70)
    cmdPanel.BorderSizePixel = 0
    local cmdPanelCorner = Instance.new("UICorner", cmdPanel)
    cmdPanelCorner.CornerRadius = UDim.new(0, 8)

    local cmdScroll = Instance.new("ScrollingFrame", cmdPanel)
    cmdScroll.Size = UDim2.new(1, -40, 1, -8)
    cmdScroll.Position = UDim2.new(0, 0, 0, 0)
    cmdScroll.BackgroundTransparency = 1
    cmdScroll.CanvasSize = UDim2.new(0, 0, 0, #config.commands * 32)
    cmdScroll.ScrollBarThickness = 8
    cmdScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    cmdScroll.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
    local cmdLayout = Instance.new("UIListLayout", cmdScroll)
    cmdLayout.SortOrder = Enum.SortOrder.LayoutOrder
    cmdLayout.Padding = UDim.new(0, 4)
    for _, v in ipairs(config.commands) do
        local cmdLabel = Instance.new("TextLabel", cmdScroll)
        cmdLabel.Size = UDim2.new(1, -8, 0, 28)
        cmdLabel.BackgroundTransparency = 1
        cmdLabel.TextColor3 = Color3.fromRGB(180, 220, 255)
        cmdLabel.Font = Enum.Font.Gotham
        cmdLabel.TextSize = 16
        cmdLabel.Text = v
        cmdLabel.TextXAlignment = Enum.TextXAlignment.Left
    end
    -- Scroll Up/Down Butonları (Commands)
    local cmdScrollUp = Instance.new("TextButton", cmdPanel)
    cmdScrollUp.Size = UDim2.new(0, 32, 0, 24)
    cmdScrollUp.Position = UDim2.new(1, -36, 0, 8)
    cmdScrollUp.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
    cmdScrollUp.Text = "▲"
    cmdScrollUp.TextColor3 = Color3.fromRGB(30,30,40)
    cmdScrollUp.Font = Enum.Font.GothamBold
    cmdScrollUp.TextScaled = true
    local cmdScrollUpCorner = Instance.new("UICorner", cmdScrollUp)
    cmdScrollUpCorner.CornerRadius = UDim.new(0, 8)

    local cmdScrollDown = Instance.new("TextButton", cmdPanel)
    cmdScrollDown.Size = UDim2.new(0, 32, 0, 24)
    cmdScrollDown.Position = UDim2.new(1, -36, 1, -32)
    cmdScrollDown.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
    cmdScrollDown.Text = "▼"
    cmdScrollDown.TextColor3 = Color3.fromRGB(30,30,40)
    cmdScrollDown.Font = Enum.Font.GothamBold
    cmdScrollDown.TextScaled = true
    local cmdScrollDownCorner = Instance.new("UICorner", cmdScrollDown)
    cmdScrollDownCorner.CornerRadius = UDim.new(0, 8)

    cmdScrollUp.MouseButton1Click:Connect(function()
        cmdScroll.CanvasPosition = Vector2.new(0, math.max(cmdScroll.CanvasPosition.Y - 32, 0))
    end)
    cmdScrollDown.MouseButton1Click:Connect(function()
        cmdScroll.CanvasPosition = Vector2.new(0, math.min(cmdScroll.CanvasPosition.Y + 32, cmdScroll.AbsoluteCanvasSize.Y - cmdScroll.AbsoluteWindowSize.Y))
    end)
    panels[1] = cmdPanel

    -- Dances Panel
    local dancePanel = Instance.new("Frame", main)
    dancePanel.Size = UDim2.new(1, -24, 1, -92)
    dancePanel.Position = UDim2.new(0, 12, 0, 80)
    dancePanel.BackgroundColor3 = Color3.fromRGB(44, 48, 70)
    dancePanel.BorderSizePixel = 0
    local dancePanelCorner = Instance.new("UICorner", dancePanel)
    dancePanelCorner.CornerRadius = UDim.new(0, 8)

    local danceScroll = Instance.new("ScrollingFrame", dancePanel)
    danceScroll.Size = UDim2.new(1, -40, 1, -8)
    danceScroll.Position = UDim2.new(0, 0, 0, 0)
    danceScroll.BackgroundTransparency = 1
    danceScroll.CanvasSize = UDim2.new(0, 0, 0, #config.dancePanelCommands * 32)
    danceScroll.ScrollBarThickness = 8
    danceScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    danceScroll.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
    local danceLayout = Instance.new("UIListLayout", danceScroll)
    danceLayout.SortOrder = Enum.SortOrder.LayoutOrder
    danceLayout.Padding = UDim.new(0, 4)
    for _, v in ipairs(config.dancePanelCommands) do
        local danceLabel = Instance.new("TextLabel", danceScroll)
        danceLabel.Size = UDim2.new(1, -8, 0, 28)
        danceLabel.BackgroundTransparency = 1
        danceLabel.TextColor3 = Color3.fromRGB(180, 255, 180)
        danceLabel.Font = Enum.Font.Gotham
        danceLabel.TextSize = 16
        danceLabel.Text = v.name
        danceLabel.TextXAlignment = Enum.TextXAlignment.Left
    end
    -- Scroll Up/Down Butonları (Dances)
    local danceScrollUp = Instance.new("TextButton", dancePanel)
    danceScrollUp.Size = UDim2.new(0, 32, 0, 24)
    danceScrollUp.Position = UDim2.new(1, -36, 0, 8)
    danceScrollUp.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
    danceScrollUp.Text = "▲"
    danceScrollUp.TextColor3 = Color3.fromRGB(30,30,40)
    danceScrollUp.Font = Enum.Font.GothamBold
    danceScrollUp.TextScaled = true
    local danceScrollUpCorner = Instance.new("UICorner", danceScrollUp)
    danceScrollUpCorner.CornerRadius = UDim.new(0, 8)

    local danceScrollDown = Instance.new("TextButton", dancePanel)
    danceScrollDown.Size = UDim2.new(0, 32, 0, 24)
    danceScrollDown.Position = UDim2.new(1, -36, 1, -32)
    danceScrollDown.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
    danceScrollDown.Text = "▼"
    danceScrollDown.TextColor3 = Color3.fromRGB(30,30,40)
    danceScrollDown.Font = Enum.Font.GothamBold
    danceScrollDown.TextScaled = true
    local danceScrollDownCorner = Instance.new("UICorner", danceScrollDown)
    danceScrollDownCorner.CornerRadius = UDim.new(0, 8)

    danceScrollUp.MouseButton1Click:Connect(function()
        danceScroll.CanvasPosition = Vector2.new(0, math.max(danceScroll.CanvasPosition.Y - 32, 0))
    end)
    danceScrollDown.MouseButton1Click:Connect(function()
        danceScroll.CanvasPosition = Vector2.new(0, math.min(danceScroll.CanvasPosition.Y + 32, danceScroll.AbsoluteCanvasSize.Y - danceScroll.AbsoluteWindowSize.Y))
    end)
    panels[2] = dancePanel

    -- Tab geçiş fonksiyonu
    local function showTab(idx)
        for i, panel in ipairs(panels) do
            panel.Visible = (i == idx)
            tabs[i].BackgroundColor3 = i == idx and Color3.fromRGB(80,180,255) or Color3.fromRGB(44,48,70)
        end
    end
    showTab(selectedTab)

    for i, tabBtn in ipairs(tabs) do
        tabBtn.MouseButton1Click:Connect(function()
            selectedTab = i
            showTab(i)
        end)
    end
end

if isAlt then
    local spinObj, orbitConn, lagConn
    local isSpinning = false
    local isOrbiting = false
    local isLagging = false

    local bangActive = false
    local bangConn = nil
    local bangAnimTrack = nil

    local headsitActive = false
    local headsitConn = nil

    local animTrack = nil

    local mirrorConn = nil
    local mirrorActive = false

    local spinorbitConn = nil
    local spinorbitActive = false

    local bodyguardConn = nil
    local bodyguardActive = false

    -- .joke komutu için fonksiyon
    local function jokeCommand()
        --Created By Armut 7#8860 Discord : https://discord.gg/q9e6W3NRSU--
        function rmesh(a)
            if not (workspace[game.Players.LocalPlayer.Name][a].Handle:FindFirstChild('Mesh') or workspace[game.Players.LocalPlayer.Name][a].Handle:FindFirstChild('SpecialMesh')) then return end
            old=game.Players.LocalPlayer.Character
            game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
            for i,v in next, workspace[game.Players.LocalPlayer.Name]:FindFirstChild(a).Handle:GetDescendants() do
                if v:IsA('Mesh') or v:IsA('SpecialMesh') then
                    v:Remove()
                end
            end
            for i = 1 , 2 do
                game.Players.LocalPlayer.Character=old
            end
        end

        HumanDied = false
        for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
            if v:IsA("BasePart") then
                _G.netless=game:GetService("RunService").Heartbeat:connect(function()
                    v.AssemblyLinearVelocity = Vector3.new(-30,0,0)
                    sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",math.huge)
                    sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",999999999)
                end)
            end
        end
        local plr = game.Players.LocalPlayer
        local char = plr.Character
        local srv = game:GetService('RunService')
        local ct = {}
        char.Archivable = true
        local reanim = char:Clone()
        reanim.Name = 'Nexo '..plr.Name..''
        fl=Instance.new('Folder',char)
        fl.Name ='Nexo'
        reanim.Animate.Disabled=true
        char.HumanoidRootPart:Destroy()
        char.Humanoid:ChangeState(16)
        for i,v in next, char.Humanoid:GetPlayingAnimationTracks() do v:Stop() end
        char.Animate:Remove()
        function create(part, parent, p, r)
            Instance.new("Attachment",part)
            Instance.new("AlignPosition",part)
            Instance.new("AlignOrientation",part)
            Instance.new("Attachment",parent)
            part.Attachment.Name = part.Name
            parent.Attachment.Name = part.Name
            part.AlignPosition.Attachment0 = part[part.Name]
            part.AlignOrientation.Attachment0 = part[part.Name]
            part.AlignPosition.Attachment1 = parent[part.Name]
            part.AlignOrientation.Attachment1 = parent[part.Name]
            parent[part.Name].Position = p or Vector3.new()
            part[part.Name].Orientation = r or Vector3.new()
            part.AlignPosition.MaxForce = 999999999
            part.AlignPosition.MaxVelocity = math.huge
            part.AlignPosition.ReactionForceEnabled = false
            part.AlignPosition.Responsiveness = math.huge
            part.AlignOrientation.Responsiveness = math.huge
            part.AlignPosition.RigidityEnabled = false
            part.AlignOrientation.MaxTorque = 999999999
        end
        for i,v in next, char:GetDescendants() do
            if v:IsA('Accessory') then
                v.Handle:BreakJoints()
                create(v.Handle,reanim[v.Name].Handle)
            end
        end
        char.Torso['Left Shoulder']:Destroy()
        char.Torso['Right Shoulder']:Destroy()
        char.Torso['Left Hip']:Destroy()
        char.Torso['Right Hip']:Destroy()
        create(char['Torso'],reanim['Torso'])
        create(char['Left Arm'],reanim['Left Arm'])
        create(char['Right Arm'],reanim['Right Arm'])
        create(char['Left Leg'],reanim['Left Leg'])
        create(char['Right Leg'],reanim['Right Leg'])
        for i,v in next, reanim:GetDescendants() do
            if v:IsA('BasePart') or v:IsA('Decal') then v.Transparency = 1 end
        end
        reanim.Parent = fl
        for i,v in next, reanim:GetDescendants() do
            if v:IsA('BasePart') then table.insert(ct,srv.RenderStepped:Connect(function() v.CanCollide = false end)) end
        end
        for i,v in next, char:GetDescendants() do
            if v:IsA('BasePart') then table.insert(ct,srv.RenderStepped:Connect(function() v.CanCollide = false end)) end
        end
        for i,v in next, reanim:GetDescendants() do
            if v:IsA('BasePart') then table.insert(ct,srv.Stepped:Connect(function() v.CanCollide = false end)) end
        end
        for i,v in next, char:GetDescendants() do
            if v:IsA('BasePart') then table.insert(ct,srv.Stepped:Connect(function() v.CanCollide = false end)) end
        end
        table.insert(ct,reanim.Humanoid.Died:Connect(function()
            plr.Character = char
            char:BreakJoints()
            reanim:Destroy()
            game.Players:Chat('-gr')
            _G.netless:Disconnect()
            HumanDied = true
            for _,v in pairs(ct) do v:Disconnect() end
        end))
        plr.Character = reanim
        workspace.CurrentCamera.CameraSubject = reanim.Humanoid

        -- Animator
        IT = Instance.new
        CF = CFrame.new
        VT = Vector3.new
        RAD = math.rad
        C3 = Color3.new
        UD2 = UDim2.new
        BRICKC = BrickColor.new
        ANGLES = CFrame.Angles
        EULER = CFrame.fromEulerAnglesXYZ
        COS = math.cos
        ACOS = math.acos
        SIN = math.sin
        ASIN = math.asin
        ABS = math.abs
        MRANDOM = math.random
        FLOOR = math.floor

        speed = 1
        sine = 1
        srv = game:GetService('RunService')

        reanim = game.Players.LocalPlayer.Character

        function hat(h,p,c1,c0,m)
            reanim[h].Handle.AccessoryWeld.Part1=reanim[p]
            reanim[h].Handle.AccessoryWeld.C1=c1 or CFrame.new()
            reanim[h].Handle.AccessoryWeld.C0=reanim[h].Handle.AccessoryWeld.C0:Lerp(c0 or CFrame.new(),1)
            if m == true then
                rmesh(h)
            end
        end

        m=game.Players.LocalPlayer:GetMouse()
        RJ = reanim.HumanoidRootPart.RootJoint
        RS = reanim.Torso['Right Shoulder']
        LS = reanim.Torso['Left Shoulder']
        RH = reanim.Torso['Right Hip']
        LH = reanim.Torso['Left Hip']
        Root = reanim.HumanoidRootPart
        NECK = reanim.Torso.Neck
        NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        RJ.C1 = CF(0,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        RS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        LS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
        LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

        coroutine.wrap(function()
            while true do -- anim changer
                if HumanDied then break end
                sine = sine + speed
                local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
                local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
                local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
                local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
                local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
                local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
                if lookvector > reanim.Humanoid.WalkSpeed then
                    lookvector = reanim.Humanoid.WalkSpeed
                end
                if lookvector < -reanim.Humanoid.WalkSpeed then
                    lookvector = -reanim.Humanoid.WalkSpeed
                end
                if rightvector > reanim.Humanoid.WalkSpeed then
                    rightvector = reanim.Humanoid.WalkSpeed
                end
                if rightvector < -reanim.Humanoid.WalkSpeed then
                    rightvector = -reanim.Humanoid.WalkSpeed
                end
                local lookvel = lookvector / reanim.Humanoid.WalkSpeed
                local rightvel = rightvector / reanim.Humanoid.WalkSpeed
                if reanim.Humanoid.Jump then -- jump
                    NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RS.C0=RS.C0:Lerp(CFrame.new(1+0*math.cos(sine/10),-0.2+1*math.cos(sine/5),-1+0*math.cos(sine/1))*CFrame.Angles(math.rad(30+0*math.cos(sine/10)),math.rad(-30+0*math.sin(sine/10)),math.rad(-20+0*math.cos(sine/10))),.2)
                    LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                elseif Root.Velocity.y < -1 and reanim.Humanoid.Jump then -- fall
                    NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RS.C0=RS.C0:Lerp(CFrame.new(1+0*math.cos(sine/10),-0.2+1*math.cos(sine/5),-1+0*math.cos(sine/1))*CFrame.Angles(math.rad(30+0*math.cos(sine/10)),math.rad(-30+0*math.sin(sine/10)),math.rad(-20+0*math.cos(sine/10))),.2)
                    LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                elseif Root.Velocity.Magnitude < 2 then -- idle
                    hat('Pal Hair','Torso',CFrame.new(0,0,0),CFrame.new(0+0*math["cos"](sine/10),1.5+0*math["cos"](sine/10),1.5+0.2*math["cos"](sine/1))*CFrame.Angles(math.rad(0+0*math["cos"](sine/10)),math.rad(0+0*math["cos"](sine/10)),math.rad(0+0*math["sin"](sine/1))),true)
                    NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RS.C0=RS.C0:Lerp(CFrame.new(1+0*math.cos(sine/10),-0.2+1*math.cos(sine/5),-1+0*math.cos(sine/1))*CFrame.Angles(math.rad(30+0*math.cos(sine/10)),math.rad(-30+0*math.sin(sine/10)),math.rad(-20+0*math.cos(sine/10))),.2)
                    LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                elseif Root.Velocity.Magnitude < 20 then -- walk
                    hat('Pal Hair','Torso',CFrame.new(0,0,0),CFrame.new(0+0*math["cos"](sine/10),1.5+0*math["cos"](sine/10),1.5+0.2*math["cos"](sine/1))*CFrame.Angles(math.rad(0+0*math["cos"](sine/10)),math.rad(0+0*math["cos"](sine/10)),math.rad(0+0*math["sin"](sine/1))),true)
                    NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RS.C0=RS.C0:Lerp(CFrame.new(1+0*math.cos(sine/10),-0.2+1*math.cos(sine/5),-1+0*math.cos(sine/1))*CFrame.Angles(math.rad(30+0*math.cos(sine/10)),math.rad(-30+0*math.sin(sine/10)),math.rad(-20+0*math.cos(sine/10))),.2)
                    LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+50*math.cos(sine/9)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+60*math.cos(sine/9)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+60*math.sin(sine/9)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                elseif Root.Velocity.Magnitude > 20 then -- run
                    hat('Pal Hair','Torso',CFrame.new(0,0,0),CFrame.new(0+0*math["cos"](sine/10),1.5+0*math["cos"](sine/10),1.5+0.2*math["cos"](sine/1))*CFrame.Angles(math.rad(0+0*math["cos"](sine/10)),math.rad(0+0*math["cos"](sine/10)),math.rad(0+0*math["sin"](sine/1))),true)
                    NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RS.C0=RS.C0:Lerp(CFrame.new(1+0*math.cos(sine/10),-0.2+1*math.cos(sine/5),-1+0*math.cos(sine/1))*CFrame.Angles(math.rad(30+0*math.cos(sine/10)),math.rad(-30+0*math.sin(sine/10)),math.rad(-20+0*math.cos(sine/10))),.2)
                    LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+50*math.cos(sine/9)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+60*math.cos(sine/9)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                    LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+60*math.sin(sine/9)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
                end
                srv.RenderStepped:Wait()
            end
        end)()
    end

    local function stopBang()
        bangActive = false
        if bangConn then bangConn:Disconnect() end
        bangConn = nil
        if bangAnimTrack then bangAnimTrack:Stop() end
        bangAnimTrack = nil
    end

    local function bangPlayer(targetPlr)
        local char = lp.Character
        local targetChar = targetPlr and targetPlr.Character
        if not char or not targetChar then return end

        local root = char:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if not root or not targetRoot then return end

        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://148840371"
        bangAnimTrack = humanoid:LoadAnimation(anim)
        bangAnimTrack.Looped = true
        bangAnimTrack:Play()
        game:GetService("Debris"):AddItem(anim, 2)

        bangActive = true
        bangConn = RunService.RenderStepped:Connect(function()
            if not bangActive or not root or not targetRoot then return end
            local behind = targetRoot.CFrame.Position - (targetRoot.CFrame.LookVector * 0.5)
            local newCFrame = CFrame.new(behind, targetRoot.Position)
            root.CFrame = root.CFrame:Lerp(newCFrame, 0.9)
            if bangAnimTrack and not bangAnimTrack.IsPlaying then
                bangAnimTrack:Play()
            end
        end)
    end

    local function stopHeadsit()
        headsitActive = false
        if headsitConn then headsitConn:Disconnect() end
        headsitConn = nil
    end

    local function headsitPlayer(targetPlr)
        stopHeadsit()
        local char = lp.Character
        local targetChar = targetPlr and targetPlr.Character
        if not char or not targetChar then return end

        local root = char:FindFirstChild("HumanoidRootPart")
        local targetHead = targetChar:FindFirstChild("Head")
        if not root or not targetHead then return end

        headsitActive = true
        headsitConn = RunService.Heartbeat:Connect(function()
            if not headsitActive or not root or not targetHead then return end
            local above = targetHead.Position + Vector3.new(0, 1.1, 0)
            root.CFrame = CFrame.new(above, targetHead.Position + Vector3.new(0, 2, 0))
            root.Velocity = Vector3.new(0,0,0)
            root.RotVelocity = Vector3.new(0,0,0)
        end)
    end

    local function playAnim(animId)
        local char = lp.Character
        if not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then return end
        if animTrack then pcall(function() animTrack:Stop() end) end

        local anim = Instance.new("Animation")
        anim.AnimationId = animId
        animTrack = hum:LoadAnimation(anim)
        animTrack.Looped = true
        animTrack:Play()
        game:GetService("Debris"):AddItem(anim, 2)
    end

    local function stopAnim()
        if animTrack then pcall(function() animTrack:Stop() end) end
        animTrack = nil
    end

    local function stopMirror()
        mirrorActive = false
        if mirrorConn then mirrorConn:Disconnect() end
        mirrorConn = nil
    end

    local function mirrorPlayer(targetPlr)
        stopMirror()
        local char = lp.Character
        local targetChar = targetPlr and targetPlr.Character
        if not char or not targetChar then return end
        local root = char:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
        if not root or not targetRoot or not hum or not targetHum then return end

        mirrorActive = true
        mirrorConn = RunService.RenderStepped:Connect(function()
            if not mirrorActive or not root or not targetRoot then return end
            root.CFrame = targetRoot.CFrame
            hum.MoveDirection = targetHum.MoveDirection
            hum.Jump = targetHum.Jump
            -- Animasyonlar için eklenebilir
        end)
    end

    local function stopSpinOrbit()
        spinorbitActive = false
        if spinorbitConn then spinorbitConn:Disconnect() end
        spinorbitConn = nil
    end

    local function spinOrbitPlayer(targetPlr)
        stopSpinOrbit()
        local char = lp.Character
        local targetChar = targetPlr and targetPlr.Character
        if not char or not targetChar then return end
        local root = char:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if not root or not targetRoot then return end

        local angle = 0
        local radius = 6
        local speed = 4
        spinorbitActive = true
        spinorbitConn = RunService.Heartbeat:Connect(function(dt)
            if not spinorbitActive or not root or not targetRoot then return end
            angle = angle + dt * speed
            local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
            root.CFrame = CFrame.new(targetRoot.Position + offset, targetRoot.Position) * CFrame.Angles(0, math.rad(720 * dt), 0)
        end)
    end

    local function stopBodyguard()
        bodyguardActive = false
        if bodyguardConn then bodyguardConn:Disconnect() end
        bodyguardConn = nil
    end

    local function bodyguardPlayer(targetPlr)
        stopBodyguard()
        local char = lp.Character
        local targetChar = targetPlr and targetPlr.Character
        if not char or not targetChar then return end
        local root = char:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if not root or not targetRoot then return end

        local angle = 0
        local radius = 3
        local speed = 6
        bodyguardActive = true
        bodyguardConn = RunService.Heartbeat:Connect(function(dt)
            if not bodyguardActive or not root or not targetRoot then return end
            angle = angle + dt * speed
            local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
            root.CFrame = CFrame.new(targetRoot.Position + offset, targetRoot.Position)
        end)
    end

    local function handleCommand(cmd, arg)
        local char = lp.Character or lp.CharacterAdded:Wait()
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then return end

        local target = nil
        if arg and arg ~= "" then
            target = findPlayerByPartialName(arg)
        end

        if cmd == "goto" and target then
            if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                char:MoveTo(target.Character.HumanoidRootPart.Position + Vector3.new(0,2,0))
            end
        end

        if cmd == "follow" and target then
            if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                if not _G._ne0e_following then
                    _G._ne0e_following = true
                    spawn(function()
                        while _G._ne0e_following and target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") do
                            local myHRP = lp.Character.HumanoidRootPart
                            local targetHRP = target.Character.HumanoidRootPart
                            local dist = (myHRP.Position - targetHRP.Position).Magnitude
                            if dist > 3 then
                                hum:MoveTo(targetHRP.Position + targetHRP.CFrame.LookVector * -2)
                            end
                            wait(0.2)
                        end
                    end)
                end
            end
        end

        if cmd == "stop" then
            _G._ne0e_following = false
            stopAnim()
            stopMirror()
            stopSpinOrbit()
            stopBodyguard()
        end

        if cmd == "spin" then
            if not isSpinning and char:FindFirstChild("HumanoidRootPart") then
                isSpinning = true
                spinObj = Instance.new("BodyAngularVelocity")
                spinObj.Name = "Ne0eSpin"
                spinObj.Parent = char.HumanoidRootPart
                spinObj.MaxTorque = Vector3.new(0, math.huge, 0)
                spinObj.AngularVelocity = Vector3.new(0, 10, 0)
            end
        end

        if cmd == "unspin" then
            isSpinning = false
            if spinObj and spinObj.Parent then
                spinObj:Destroy()
            end
        end

        if cmd == "orbit" and target then
            if not isOrbiting and char:FindFirstChild("HumanoidRootPart") then
                isOrbiting = true
                local radius = 6
                local speed = 2
                local angle = 0
                orbitConn = RunService.Heartbeat:Connect(function(dt)
                    if not isOrbiting or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then return end
                    angle = angle + dt * speed
                    local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
                    char.HumanoidRootPart.CFrame = CFrame.new(target.Character.HumanoidRootPart.Position + offset, target.Character.HumanoidRootPart.Position)
                end)
            end
        end

        if cmd == "unorbit" then
            isOrbiting = false
            if orbitConn then
                orbitConn:Disconnect()
                orbitConn = nil
            end
        end

        if cmd == "fling" and target then
            local char = lp.Character or lp.CharacterAdded:Wait()
            local hrp = char:FindFirstChild("HumanoidRootPart")
            for _, v in pairs(char:GetChildren()) do
                if v:IsA("BasePart") then
                    v.Massless = true
                end
            end

            if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                local targetHRP = target.Character.HumanoidRootPart
                local bav = Instance.new("BodyAngularVelocity", targetHRP)
                bav.Name = "Ne0eTargetFlingBAV"
                bav.AngularVelocity = Vector3.new(0, 1E5, 0)
                bav.MaxTorque = Vector3.new(0, math.huge, 0)
                bav.P = math.huge

                local t = tick()
                while tick() - t < 1.2 and target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") do
                    hrp.CFrame = target.Character.HumanoidRootPart.CFrame
                    bav.AngularVelocity = Vector3.new(0, 1E5, 0)
                    RunService.Heartbeat:Wait()
                end

                bav:Destroy()
            end
        end

        if cmd == "lag" then
            if not isLagging then
                isLagging = true
                lagConn = RunService.Heartbeat:Connect(function()
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.CFrame = char.HumanoidRootPart.CFrame * CFrame.new(math.random(-2,2), math.random(-2,2), math.random(-2,2))
                    end
                end)
            end
        end

        if cmd == "unlag" then
            isLagging = false
            if lagConn then
                lagConn:Disconnect()
                lagConn = nil
            end
        end

        if cmd == "re" then
            if hum then
                hum.Health = 0
            end
        end

        if cmd == "chat" and arg and arg ~= "" then
            if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
                local channel = TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
                if channel then
                    channel:SendAsync(arg)
                end
            else
                local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                if chatEvent then
                    local say = chatEvent:FindFirstChild("SayMessageRequest")
                    if say then
                        say:FireServer(arg, "All")
                    end
                end
            end
        end

        if cmd == "bang" and target then
            stopBang()
            bangPlayer(target)
        end

        if cmd == "unbang" then
            stopBang()
        end

        if cmd == "headsit" and target then
            headsitPlayer(target)
        end

        if cmd == "unheadsit" then
            stopHeadsit()
        end

        -- DANCE KOMUTLARI (eski klasik sistem)
        if cmd == "dance1" then
            playAnim("rbxassetid://182435998") -- Dance1
            return
        elseif cmd == "dance2" then
            playAnim("rbxassetid://182436842") -- Dance2
            return
        elseif cmd == "dance3" then
            playAnim("rbxassetid://182436935") -- Dance3
            return
        elseif cmd == "headthrow" then
            playAnim("rbxassetid://35154961")
            return
        elseif cmd == "infiniterunnerrun" then
            playAnim("rbxassetid://252557606")
            return
        end

        -- .joke komutu
        if cmd == "joke" then
            jokeCommand()
            return
        end

        -- .mirror <kullanıcı>
        if cmd == "mirror" and target then
            mirrorPlayer(target)
        end

        -- .spinorbit <kullanıcı>
        if cmd == "spinorbit" and target then
            spinOrbitPlayer(target)
        end

        -- .bodyguard <kullanıcı>
        if cmd == "bodyguard" and target then
            bodyguardPlayer(target)
        end

        -- .quit
        if cmd == "quit" then
            if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
                local channel = TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
                if channel then
                    channel:SendAsync("Quitting...")
                end
            else
                local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                if chatEvent then
                    local say = chatEvent:FindFirstChild("SayMessageRequest")
                    if say then
                        say:FireServer("Quitting...", "All")
                    end
                end
            end
            wait(0.5)
            lp:Kick("Quitting...")
        end
    end

    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        TextChatService.MessageReceived:Connect(function(msg)
            if msg.TextSource and msg.TextSource.Name == config.mainAccount then
                local text = msg.Text
                local cmd, arg = text:match("^%.(%w+)%s*(.*)")
                if cmd then
                    handleCommand(cmd:lower(), arg)
                end
            end
        end)
    else
        for _, player in ipairs(Players:GetPlayers()) do
            player.Chatted:Connect(function(message)
                if player.Name == config.mainAccount then
                    local cmd, arg = message:match("^%.(%w+)%s*(.*)")
                    if cmd then
                        handleCommand(cmd:lower(), arg)
                    end
                end
            end)
        end
        Players.PlayerAdded:Connect(function(player)
            player.Chatted:Connect(function(message)
                if player.Name == config.mainAccount then
                    local cmd, arg = message:match("^%.(%w+)%s*(.*)")
                    if cmd then
                        handleCommand(cmd:lower(), arg)
                    end
                end
            end)
        end)
    end
end

if isAlt then
    -- Otomatik bot mesajları
    local botMessages = {
        "I am a bot made by Ne0e.",
        "I am here to help my main account.",
        "Ne0e's Alt Account is online.",
        "I can follow, spin, orbit and more!",
        "Type .help on main for commands.",
        "I am always watching.",
        "I am your loyal bot.",
        "Script by Ne0e.",
        "I run on pure Ne0e energy.",
        "Bots have more fun.",
        "I never sleep."
    }

    spawn(function()
        while true do
            wait(math.random(60, 120))
            local msg = botMessages[math.random(1, #botMessages)]
            local TextChatService = game:GetService("TextChatService")
            if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
                local channel = TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
                if channel then
                    channel:SendAsync(msg)
                end
            else
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                if chatEvent then
                    local say = chatEvent:FindFirstChild("SayMessageRequest")
                    if say then
                        say:FireServer(msg, "All")
                    end
                end
            end
        end
    end)

    -- Rastgele yürüme ve selam verme
    spawn(function()
        local Players = game:GetService("Players")
        local lp = Players.LocalPlayer
        while true do
            wait(math.random(15, 35))
            local myChar = lp.Character
            local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if myChar and myHum and myRoot then
                if math.random() < 0.5 then
                    local offset = Vector3.new(math.random(-20,20), 0, math.random(-20,20))
                    local targetPos = myRoot.Position + offset
                    myHum:MoveTo(targetPos)
                else
                    local others = {}
                    for _,plr in ipairs(Players:GetPlayers()) do
                        if plr ~= lp and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                            table.insert(others, plr)
                        end
                    end
                    if #others > 0 then
                        local target = others[math.random(1, #others)]
                        local targetRoot = target.Character.HumanoidRootPart
                        myHum:MoveTo(targetRoot.Position + Vector3.new(0,0,2))
                        local reached = false
                        local conn
                        conn = myHum.MoveToFinished:Connect(function()
                            reached = true
                            if conn then conn:Disconnect() end
                        end)
                        local t0 = tick()
                        while not reached and tick()-t0 < 8 do
                            wait(0.2)
                        end
                        local msg = "hi " .. target.Name
                        local TextChatService = game:GetService("TextChatService")
                        if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
                            local channel = TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
                            if channel then
                                channel:SendAsync(msg)
                            end
                        else
                            local ReplicatedStorage = game:GetService("ReplicatedStorage")
                            local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                            if chatEvent then
                                local say = chatEvent:FindFirstChild("SayMessageRequest")
                                if say then
                                    say:FireServer(msg, "All")
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end
